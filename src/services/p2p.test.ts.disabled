import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';

// Mocks globaux
vi.mock('peerjs', () => {
  return {
    default: function MockPeer(id) {
      return {
        id: id || Math.random().toString(36).substring(2, 10),
        connections: {},
        destroyed: false,
        
        // EventEmitter-like functionality
        _listeners: new Map(),
        on: function(event, callback) {
          if (!this._listeners.has(event)) {
            this._listeners.set(event, []);
          }
          this._listeners.get(event).push(callback);
          return this;
        },
        
        emit: function(event, ...args) {
          if (this._listeners.has(event)) {
            for (const callback of this._listeners.get(event)) {
              callback(...args);
            }
          }
          return true;
        },
        
        connect: function(peerId) {
          const connection = {
            peer: peerId,
            open: false,
            metadata: null,
            
            // EventEmitter-like functionality
            _listeners: new Map(),
            on: function(event, callback) {
              if (!this._listeners.has(event)) {
                this._listeners.set(event, []);
              }
              this._listeners.get(event).push(callback);
              return this;
            },
            
            emit: function(event, ...args) {
              if (this._listeners.has(event)) {
                for (const callback of this._listeners.get(event)) {
                  callback(...args);
                }
              }
              return true;
            },
            
            send: vi.fn(),
            close: function() {
              this.open = false;
              this.emit('close');
            }
          };
          
          this.connections[peerId] = connection;
          return connection;
        },
        
        destroy: function() {
          this.destroyed = true;
          this.id = null;
        }
      };
    }
  };
});

import { P2PService } from './p2p';

describe('P2P Service', () => {
  let p2pService;
  let mockPeer;
  let originalConsoleError;
  
  beforeEach(() => {
    // Préserver la console.error originale
    originalConsoleError = console.error;
    console.error = vi.fn();
    
    // Créer une nouvelle instance du service pour chaque test
    p2pService = new P2PService();
    mockPeer = p2pService['peer'];
  });
  
  afterEach(() => {
    // Restaurer console.error
    console.error = originalConsoleError;
    
    // Nettoyer
    if (p2pService) {
      p2pService.disconnect();
    }
  });
  
  it('should initialize with DISCONNECTED state', () => {
    expect(p2pService.connectionState).toBe('disconnected');
  });
  
  it('should connect to the network and generate peer ID', async () => {
    const connectPromise = p2pService.connect();
    
    // Simuler une connexion réussie
    mockPeer.emit('open', 'test-peer-id');
    
    await connectPromise;
    
    expect(p2pService.connectionState).toBe('connected');
    expect(p2pService.peerId).toBe('test-peer-id');
  });
  
  it('should handle connection errors', async () => {
    const connectPromise = p2pService.connect();
    
    // Simuler une erreur de connexion
    mockPeer.emit('error', new Error('Connection failed'));
    
    await expect(connectPromise).rejects.toThrow('Connection failed');
    expect(p2pService.connectionState).toBe('error');
  });
  
  it('should connect to a peer', async () => {
    // D'abord, connecter au réseau
    const connectPromise = p2pService.connect();
    mockPeer.emit('open', 'local-peer-id');
    await connectPromise;
    
    // Ensuite, connecter à un pair
    const remotePeerId = 'remote-peer-id';
    const connectionPromise = p2pService.connectToPeer(remotePeerId);
    
    // Récupérer la connexion créée
    const mockConnection = mockPeer.connections[remotePeerId];
    expect(mockConnection).toBeDefined();
    
    // Simuler une connexion réussie
    mockConnection.emit('open');
    
    await connectionPromise;
    
    // Vérifier que le pair est ajouté à la liste
    expect(p2pService.peers.has(remotePeerId)).toBe(true);
  });
  
  it('should disconnect from network', async () => {
    // D'abord, connecter au réseau
    const connectPromise = p2pService.connect();
    mockPeer.emit('open', 'local-peer-id');
    await connectPromise;
    
    // Ensuite, se déconnecter
    p2pService.disconnect();
    
    expect(p2pService.connectionState).toBe('disconnected');
    expect(p2pService.peerId).toBeNull();
    expect(p2pService.peers.size).toBe(0);
    expect(mockPeer.destroyed).toBe(true);
  });
  
  it('should send message to a peer', async () => {
    // D'abord, connecter au réseau
    const connectPromise = p2pService.connect();
    mockPeer.emit('open', 'local-peer-id');
    await connectPromise;
    
    // Ensuite, connecter à un pair
    const remotePeerId = 'remote-peer-id';
    const connectionPromise = p2pService.connectToPeer(remotePeerId);
    
    // Récupérer la connexion créée
    const mockConnection = mockPeer.connections[remotePeerId];
    
    // Simuler une connexion réussie
    mockConnection.emit('open');
    
    await connectionPromise;
    
    // Espionner la méthode send
    const sendSpy = vi.spyOn(mockConnection, 'send');
    
    // Envoyer un message
    const message = { type: 'chat', content: 'Hello!' };
    p2pService.sendToPeer(remotePeerId, message);
    
    expect(sendSpy).toHaveBeenCalledWith(message);
  });
  
  it('should handle incoming connections', async () => {
    // D'abord, connecter au réseau
    const connectPromise = p2pService.connect();
    mockPeer.emit('open', 'local-peer-id');
    await connectPromise;
    
    // Créer un mock pour l'événement de réception de message
    const messageHandler = vi.fn();
    p2pService.onMessage(messageHandler);
    
    // Simuler une connexion entrante
    const remotePeerId = 'incoming-peer-id';
    const mockConnection = {
      peer: remotePeerId,
      _listeners: new Map(),
      on: function(event, callback) {
        if (!this._listeners.has(event)) {
          this._listeners.set(event, []);
        }
        this._listeners.get(event).push(callback);
        return this;
      },
      emit: function(event, ...args) {
        if (this._listeners.has(event)) {
          for (const callback of this._listeners.get(event)) {
            callback(...args);
          }
        }
        return true;
      }
    };
    
    mockPeer.emit('connection', mockConnection);
    
    // Simuler l'ouverture de la connexion
    mockConnection.emit('open');
    
    expect(p2pService.peers.has(remotePeerId)).toBe(true);
    
    // Simuler la réception d'un message
    const testMessage = { type: 'chat', content: 'Incoming message' };
    mockConnection.emit('data', testMessage);
    
    expect(messageHandler).toHaveBeenCalledWith(testMessage, remotePeerId);
  });
}); 